   Link: Επεξεργασία (alternate)
   Link: Επεξεργασία (edit)
   Link: Βικιπαίδεια (el) (search)
   Link: copyright
   Link: Βικιπαίδεια Atom Συνδρομή (alternate)

                                      Ruby

   Από τη Βικιπαίδεια, την ελεύθερη
   εγκυκλοπαίδεια
   Μετάβαση σε: πλοήγηση, αναζήτηση

   Η Ruby είναι μια δυναμική, ανακλαστική,
   αντικειμενοστρεφής γλώσσα
   προγραμματισμού γενικής χρήσης που
   συνδυάζει μια σύνταξη επηρεασμένη από
   την Perl με χαρακτηριστικά από τη Smalltalk. Η
   Ruby προήλθε από την Ιαπωνία στα μέσα της
   δεκαετίας του 1990 και αρχικά σχεδιάστηκε
   και αναπτύχθηκε από τον Yukihiro "Matz" Matsumoto.
   Βασικές της επιρροές είναι η Perl, η Smalltalk,
   η Eiffel και η Lisp.

   Η Ruby υποστηρίζει πολλαπλά παραδείγματα
   προγραμματισμού όπως ο συναρτησιακός
   προγραμματισμός, ο αντικειμενοστρεφής
   προγραμματισμός, ο προστακτικός
   προγραμματισμός και ο ανακλαστικός
   (reflective) προγραμματισμός. Έχει σύστημα
   δυναμικών τύπων και αυτόματη διαχείριση
   μνήμης, επομένως μοιάζει σε κάποια
   χαρακτηριστικά της με την Python, την Perl, τη
   Lisp, τη Dylan, την Pike και τη CLU.

   Η πρότυπη υλοποίηση 1.8.7 της Ruby είναι
   γραμμένη σε C, σαν μια διερμηνευόμενη
   γλώσσα ενός περάσματος. Προς το παρόν
   δεν υπάρχει κάποιο επίσημο πρότυπο
   αναφοράς για τη γλώσσα Ruby, επομένως η
   αρχική υλοποίηση θεωρείται το ντε φάκτο
   σημείο αναφοράς. Υπάρχουν αρκετές
   (ολοκληρωμένες ή σε ανάπτυξη)
   εναλλακτικές υλοποιήσεις της γλώσσας,
   συμπεριλαμβανομένων των YARV, JRuby, Rubinius,
   IronRuby, MacRuby και HotRuby, κάθε μια από τις
   οποίες και έχει διαφορετική προσέγγιση,
   με τις IronRuby, JRuby και MacRuby να προσφέρουν
   just-in-time compilation και τη MacRuby να προσφέρει
   επιπλέον ahead-of-time compilation. Ο κώδικας της
   επίσημης έκδοσης 1.9 χρησιμοποιεί τη YARV,
   όπως και αυτός της έκδοσης 2.0 (σε
   ανάπτυξη), η οποία και θα αντικαταστήσει
   την πιο αργή Ruby MRI.

   Πίνακας περιεχομένων

     * 1 Ιστορία

          * 1.1 Ετυμολογία του ονόματος "Ruby"
          * 1.2 Αρχική δημοσιοποίηση
          * 1.3 Ruby 1.0
          * 1.4 Ruby on Rails
          * 1.5 Ruby 1.9.1

     * 2 Φιλοσοφία
     * 3 Χαρακτηριστικά
     * 4 Σημασιολογία
     * 5 Σύνταξη
     * 6 Διαφορές στη συμπεριφορά σε σχέση με
       άλλες γλώσσες
     * 7 Αλληλεπίδραση
     * 8 Παραδείγματα

          * 8.1 Συμβολοσειρές
          * 8.2 Συλλογές
          * 8.3 Ενότητες και απαριθμητές
          * 8.4 Κλάσεις

               * 8.4.1 Ανοιχτές κλάσεις

          * 8.5 Εξαιρέσεις
          * 8.6 Μεταπρογραμματισμός

     * 9 Υλοποιήσεις
     * 10 Αποθήκες κώδικα και βιβλιοθήκες
     * 11 Δείτε επίσης
     * 12 Αναφορές
     * 13 Βιβλιογραφία
     * 14 Εξωτερικοί σύνδεσμοι

[Επεξεργασία] Ιστορία

   [IMG]
   [IMG]
   Yukihiro Matsumoto, ο δημιουργός της Ruby.

   Η αρχική ιδέα για τη Ruby προέκυψε στις 24
   Φεβρουαρίου 1993 από το Yukihiro Matsumoto που είχε
   σκοπό να δημιουργήσει μια νέα γλώσσα που
   θα ισορροπούσε μεταξύ συναρτησιακού και
   προστακτικού προγραμματισμού.^[1] Ο Matsumoto
   έχει δηλώσει: "Ήθελα μια γλώσσα σεναρίων
   πιο ισχυρή από την Perl και πιο
   αντικειμενοστρεφή από την Python. Για αυτό
   αποφάσισα να σχεδιάσω τη δική μου
   γλώσσα".^[2]

  [Επεξεργασία] Ετυμολογία του ονόματος "Ruby"

   Το όνομα "Ruby" αποφασίστηκε στη διάρκεια
   μιας ηλεκτρονικής συνομιλίας μεταξύ του
   Matsumoto και του Keiju Ishitsuka στις 24 Φεβρουαρίου
   του 1993, πριν γραφεί κώδικας για τη
   γλώσσα.^[3] Αρχικά προτάθηκαν δύο ονόματα:
   "Coral" και "Ruby", με το τελευταίο να είναι η
   επιλογή του Matsumoto σε ένα μήνυμα
   ηλεκτρονικής αλληλογραφίας στη
   συνέχεια στον Ishitsuka.^[4] Ο Matsumoto αργότερα
   είχε δηλώσει ότι ένας παράγοντας υπερ
   της επιλογής του ονόματος "Ruby" ήταν το
   ότι βρισκόταν στην "πέτρα γενεθλίων"
   (birthstone) ενός από τους συναδέλφους του.^[5]

  [Επεξεργασία] Αρχική δημοσιοποίηση

   Η πρώτη δημόσια έκδοση της Ruby 0.95
   ανακοινώθηκε σε εγχώριες ομάδες νέων
   (newsgroups) της Ιαπωνίας την 21η Δεκεμβρίου
   1995.^[6]^[7] Στη συνέχεια τρεις εκδόσεις της
   Ruby έγιναν διαθέσιμες στο διάστημα δύο
   ημερών^[3], ταυτόχρονα με τη δημιουργία
   της λίστας ηλεκτρονικού ταχυδρομείου
   ruby-list (στην Ιαπωνική γλώσσα), η οποία ήταν
   η πρώτη λίστα για τη νέα γλώσσα.

   Ήδη σε αυτή τη φάση της ανάπτυξης ήταν
   παρόντα αρκετά από τα χαρακτηριστικά
   που έγιναν γνώριμα από τις επόμενες
   εκδόσεις της Ruby, όπως η
   αντικειμενοστρεφής σχεδίαση, οι κλάσεις
   με κληρονομικότητα, τα mixin, οι
   απαριθμητές (iterators), τα κλεισίματα (closures),
   ο χειρισμός εξαιρέσεων (exception handling), και η
   συλλογή σκουπιδιών (garbage collection).^[8]

  [Επεξεργασία] Ruby 1.0

   Η Ruby έφτασε την έκδοση 1.0 στις 25
   Δεκεμβρίου 1996.^[3]

   Μετά την έκδοση Ruby 1.3 το 1999, άρχισε η
   πρώτη λίστα ταχυδρομείου στην αγγλική
   γλώσσα, η ruby-talk,^[2] που υπήρξε η αρχή ενός
   αυξανόμενου ενδιαφέροντος για τη γλώσσα
   εκτός Ιαπωνίας. Το Σεπτέμβριο του 2000,
   τυπώθηκε το πρώτο βιβλίο στην αγγλική,
   το "Programming Ruby", το οποίο και αργότερα
   δημοσιεύθηκε ελεύθερα για το κοινό,
   ωθώντας και άλλο τη χρήση της Ruby στον
   αγγλόφωνο κόσμο.

  [Επεξεργασία] Ruby on Rails

           Δείτε επίσης: Ruby on Rails

   Το 2005, το ενδιαφέρον για τη γλώσσα Ruby
   εκτοξεύθηκε σε συνδυασμό με το Ruby on Rails,
   ένα πλαίσιο ανάπτυξης Web εφαρμογών (web
   application framework) γραμμένο σε Ruby. Το Rails συχνά
   θεωρείται ότι έκανε "διάσημη" τη Ruby και
   συνδέεται τόσο στενά με αυτήν που συχνά
   οι νέοι προγραμματιστές σε Ruby θεωρούν τη
   γλώσσα και το πλαίσιο ταυτόσημα.^[9]

  [Επεξεργασία] Ruby 1.9.1

   Η Ruby 1.9.1 εισάγει κάποιες σημαντικές
   αλλαγές σε σχέση με την έκδοση 1.8.6.
   Κάποια παραδείγματα ακολουθούν:

     * Τοπικές μεταβλητές (μεταβλητές που
       είναι ορατές μόνο στην ενότητα/block
       στην οποία δηλώθηκαν)
     * Επιπλέον σύνταξη για λ-εκφράσεις (fun =
       ->(a,b) { puts a + b })
     * Υποστηρίζονται κωδικοποιήσεις
       χαρακτήρων ανά συμβολοσειρά

[Επεξεργασία] Φιλοσοφία

   Ο Matsumoto έχει πει ότι η Ruby έχει σχεδιαστεί
   για παραγωγικότητα και ευχάριστη χρήση
   από τον προγραμματιστή, ακολουθώντας
   τις αρχές της καλής σχεδίασης διεπαφών
   χρήστη.^[10] Τονίζει ότι η σχεδίαση
   συστημάτων πρέπει να δίνει έμφαση στις
   ανθρώπινες ανάγκες, και όχι σε αυτές του
   υπολογιστή:^[11]

         Συχνά οι άνθρωποι, ειδικά οι
     μηχανικοί υπολογιστών, εστιάζουν στους
     υπολογιστές. Σκέφτονται: "Κάνοντας
     αυτό, ο υπολογιστής θα τρέξει πιο
     γρήγορα. Κάνοντας αυτό, ο υπολογιστής
     θα τρέξει πιο αποδοτικά. Κάνοντας αυτό,
     ο υπολογιστής θα ..." Εστιάζουν την
     προσοχή τους στους υπολογιστές. Αλλά
     στην πραγματικότητα πρέπει να
     εστιάσουμε στους ανθρώπου, στο πώς οι
     άνθρωποι προγραμματίζουν ή
     χειρίζονται τις εφαρμογές των
     υπολογιστών. Είμαστε τα αφεντικά. Είναι
     οι σκλάβοι.

   Η Ruby λέγεται ότι ακολουθεί την "αρχή της
   ελάχιστης έκπληξης", το οποίο σημαίνει
   ότι η γλώσσα πρέπει να συμπεριφέρεται
   έτσι ώστε να μην μπερδεύονται οι
   έμπειροι χρήστες της. Ο Matsumoto έχει πει
   ότι ο βασικός στόχος της σχεδίασής του
   ήταν να δημιουργήσει μια γλώσσα, την
   οποία θα απολάμβανε ο ίδιος να
   χρησιμοποιεί, ελαχιστοποιώντας την
   προγραμματιστική δουλειά και τα πιθανά
   διφορούμενα σημεία. Έχει πει ότι δεν δεν
   είχε εφαρμόσει την αρχή της ελάχιστης
   έκπληξης στη Ruby,^[11] αλλά η φράση έχει πια
   συνδεθεί στενά με αυτήν. Η φράση η ίδια
   έχει υπάρξη πηγή εκπλήξεων, αφού οι
   αρχάριοι χρήστες πιστεύουν ότι σημαίνει
   ότι οι συμπεριφορές της Ruby προσπαθούν να
   μοιάσουν σε αυτές άλλων γνώριμων
   γλωσσών. Σε μια συζήτηση το Μάιο του 2005
   στην ομάδα comp.lang.ruby, ο Matsumoto προσπάθησε να
   κρατήσει μια απόσταση μεταξύ της Ruby και
   της παραπάνω "αρχής", εξηγώντας ότι, αφού
   κάθε σχεδιαστική απόφαση θα καταπλήξει
   κάποιον, χρησιμοποιεί ένα προσωπικό
   μέτρο για την αποτίμηση της "έκπληξης".
   Αν αυτό το προσωπικό μέτρο παραμένει
   συνεπές, θα υπάρχουν λίγες εκπλήξεις για
   αυτούς που το γνωρίζουν.^[12]

   Ο Matsumoto το περιέγραψε ως εξής σε μια
   συνέντευξη:^[11]

         Κάθε άνθρωπος έχει ένα προσωπικό
     παρελθόν. Κάποιος μπορεί να ήρθε από
     την Python, κάποιος άλλος από την Perl, και
     μπορεί να εκπλαγούν από διάφορες όψεις
     της γλώσσας. Τότε έρχονται και μου λένε,
     'ένιωσα έκπληξη από αυτό το
     χαρακτηριστικό της γλώσσας, η Ruby
     παραβαίνει την αρχή της ελάχιστης
     έκπληξης.' Περίμενε. Περίμενε. Η αρχή
     της ελάχιστης έκπληξης δεν είναι μόνο
     για εσένα. Η αρχή της ελάχιστης
     έκπληξης σημαίνει την αρχή της
     ελάχιστης δικής μου έκπληξης. Και αυτό
     σημαίνει ότι ισχύει όταν έχεις μάθει τη
     Ruby αρκετά καλά. Για παράδειγμα, ήμουν
     προγραμματιστής της C++ πριν αρχίσω τη
     σχεδίαση της Ruby. Προγραμμάτιζα
     αποκλειστικά σε C++ για δύο με τρία
     χρόνια. Και μετά από δύο χρόνια
     προγραμματισμού με C++, η γλώσσα αυτή
     εξακολουθεί να με εκπλήσσει.

[Επεξεργασία] Χαρακτηριστικά

     * Πλήρως αντικειμενοστρεφής με
       κληρονομικότητα, mixin, και
       μετακλάσεις^[13]
     * Δυναμικοί τύποι και Duck typing
     * Τα πάντα είναι εκφράσεις (ακόμα και οι
       εντολές) και τα πάντα εκτελούνται
       προστακτικά (ακόμα και οι δηλώσεις)
     * Σύντομη και ευέλικτη σύνταξη ^[14] που
       ελαχιστοποιεί το "συντακτικό θόρυβο"
       και είναι η βάση για γλώσσες
       συγκεκριμένων πεδίων (domain specific
       languages)^[15]
     * Δυναμική ανάκλαση και τροποποίηση
       αντικειμένων στο χρόνο εκτέλεσης για
       τη διευκόλυνση του
       μεταπρογραμματισμού
     * Κλεισίματα, απαριθμητές και
       γεννήτριες, με μια μοναδική σύνταξη
       ενοτήτων (blocks)^[16]
     * Ρητός συμβολισμός για δυναμικούς
       πίνακες, πίνακες κατακερματισμού
       (hashes), κανονικές εκφράσεις και σύμβολα
     * Ενσωμάτωση κώδικα σε συμβολοσειρές
       (variable interpolation)
     * Παράμετροι με εξορισμού τιμές (Default
       arguments)
     * Τέσσερα επίπεδα εμβέλειας μεταβλητών:
       καθολική, κλάσης, στιγμιότυπου κλάσης
       και τοπική, που σημειώνονται με
       σύμβολα (sigils) και χρήση
       κεφαλαίων-μικρών ανά περίπτωση
     * Αυτόματη συλλογή σκουπιδιών
     * Συνέχειες (continuations) πρώτης τάξης
     * Αυστηροί κανόνες έμμεσης μετατροπής
       τιμών αληθείας (τα πάντα είναι αληθή
       εκτός του false και του nil)
     * Χειρισμός εξαιρέσεων
     * Υπερφόρτωση τελεστών
     * Ενσωματωμένη υποστήριξη για ρητούς
       αριθμούς, μιγαδικούς αριθμούς και
       αριθμητική άπειρης ακρίβειας
     * Ρυθμιζόμενη διανομή των κλήσεων
       μεθόδων (dispatch) (με τις method_missing και
       const_missing)
     * Εγγενή νήματα και συνεργατικές ίνες
       (cooperative fibers)
     * Αρχική υποστήριξη για το πρότυπο Unicode
       και πολλαπλές κωδικοποιήσεις
       χαρακτήρων (αν και με κάποια
       προβλήματα μέχρι την έκδοση 1.9)^[17]
     * plug-in API σε C
     * Το κέλυφος Ruby
     * Κεντρική διαχείριση πακέτων μέσω των
       RubyGems
     * Έχει υλοποιηθεί σε όλες τις
       σημαντικές πλατφόρμες
     * Μεγάλη βασική βιβλιοθήκη

[Επεξεργασία] Σημασιολογία

   Η Ruby είναι αντικειμενοστρεφής: κάθε
   τύπος δεδομένων είναι αντικείμενο,
   συμπεριλαμβανομένων και των κλάσεων και
   των τύπων που άλλες γλώσσες θεωρούν
   βασικούς (όπως οι ακέραιοι, οι τιμές
   αλήθειας και η τιμή "nil"). Κάθε συνάρτηση
   είναι μια μέθοδος. Οι τιμές με όνομα
   (μεταβλητές) πάντα είναι αναφορές σε
   αντικείμενα, και όχι τα ίδια τα
   αντικείμενα. Η Ruby υποστηρίζει
   κληρονομικότητα με δυναμική διανομή
   μεθόδων (dynamic dispatch), mixin και μεθόδους singleton
   (που ανήκουν και ορίζονται μόνο σε ένα
   αντικείμενο και όχι σε ολόκληρη την
   κλάση). Αν και η Ruby δεν υποστηρίζει
   πολλαπλή κληρονομικότητα, οι κλάσεις
   μπορούν να εισάγουν μονάδες κώδικα (modules)
   σαν mixin. Η διαδικαστική σύνταξη
   υποστηρίζεται αλλά όλες οι μέθοδοι που
   ορίζονται εκτός της εμβέλειας ενός
   συγκεκριμένου αντικειμένου είναι στην
   πραγματικότητα μέθοδοι της κλάσης Object.
   Επειδή η κλάση αυτή είναι η βασική κλάση
   κάθε άλλης βάσης, οι αλλαγές είναι
   ορατές σε όλες τις κλάσεις και τα
   αντικείμενα.

   Η Ruby έχει περιγραφεί σαν γλώσσα
   προγραμματισμού πολλών παραδειγμάτων:
   επιτρέπει διαδικαστικό προγραμματισμό
   (ο ορισμός συναρτήσεων/μεταβλητών εκτός
   κλάσεων τις κάνει μέρος της κλάσης
   ρίζας, 'self' Object), με αντικειμενοστρεφή
   χαρακτηριστικά (τα πάντα είναι
   αντικείμενα) ή συναρτησιακά
   χαρακτηριστικά και συνέχειες - όλες οι
   εντολές έχουν τιμές, και οι συναρτήσεις
   επιστρέφουν την τελευταία τιμή τους).
   Επιτρέπει ενδοσκόπηση (introspection),
   ανάκλαση (reflection) και μεταπρογραμματισμό,
   και υποστηρίζει ^[18] νήματα βασισμένα στο
   διερμηνέα. Η Ruby έχει δυναμικό σύστημα
   τύπων και υποστηρίζει τον παραμετρικό
   πολυμορφισμό.

   Σύμφωνα με τη λίστα συχνών ερωτήσεων της
   Ruby,^[19]:

         "Αν σας αρέσει η Perl, θα σας αρέσει η Ruby
     και θα νιώσετε άνετα με τη σύνταξή της.
     Αν σας αρέσει η Smalltalk, θα σας αρέσει η Ruby
     και θα νιώσετε άνετα με τη σημασιολογία
     της. Αν σας αρέσει η Python, μπορεί (ή
     μπορεί και όχι) να σας ξενίσει η
     τεράστια διαφορά στη φιλοσοφία
     σχεδίασης μεταξύ της Python και των Ruby/Perl."


[Επεξεργασία] Σύνταξη

   Η σύνταξη της Ruby είναι παρόμοια με αυτή
   της Perl και της Python. Οι ορισμοί κλάσεων
   και μεθόδων ξεχωρίζουν από
   λέξεις-κλειδιά. Σε αντίθεση με την Perl,
   δεν είναι απαραίτητο οι μεταβλητές να
   έχουν στην αρχή τους ένα αναγνωριστικό
   σύμβολο. Όταν αυτό όμως χρησιμοποιείται
   αλλάζει η σημασία της εμβέλειας της
   μεταβλητής. Η εμφανέστερη διαφορά σε
   σχέση με τη C και την Perl είναι ότι συνήθως
   χρησιμοποιούνται λέξεις-κλειδιά για τον
   ορισμό λογικών ενοτήτων κώδικα, χωρίς
   αγκύλες (δηλ., ζευγάρι { και }). Για
   πρακτικούς λόγους, δεν υπάρχει
   διαχωρισμός μεταξύ εκφράσεων και
   εντολών^[20]. Οι αλλαγές γραμμής είναι
   σημαντικές και αποτελούν το τέλος μιας
   εντολής - επίσης μπορεί να
   χρησιμοποιηθεί ένα ελληνικό
   ερωτηματικό στη θέση τους. Σε
   αντιδιαστολή με την Python, οι εσοχές
   (indentation) δεν έχουν σημασία.

   Μια από τις διαφορές της Ruby σε σχέση με
   την Python και την Perl είναι ότι η Ruby κρατά
   όλες τις μεταβλητές ενός αντικειμένου
   σαν ιδιωτικές (private) μέσα σε μια κλάση και
   τις εκθέτει προς τα έξω μόνο μέσω
   μεθόδων πρόσβασης (attr_writer, attr_reader, κλπ.).
   Σε αντίθεση με τις μεθόδους "getter" και
   "setter" άλλων γλωσσών όπως η C++ ή η Java, οι
   μέθοδοι πρόσβασης στη Ruby δημιουργούνται
   με μια γραμμή κώδικα με χρήση
   μεταπρογραμματισμού. Επειδή η κλήση
   αυτών των μεθόδων δε χρειάζεται
   παρενθέσεις, είναι εύκολο να αλλάξουμε
   μια μεταβλητή ενός αντικειμένου σε μια
   πλήρη συνάρτηση, χωρίς να αλλάξουμε ούτε
   μια γραμμή κώδικα ή refactoring,
   επιτυγχάνοντας παρόμοια
   λειτουργικότητα με τα μέλη ιδιοτήτων
   της C# και της VB.NET. Οι περιγραφείς
   ιδιοτήτων της Python (property descriptors) είναι
   παρόμοιοι αλλά έχουν ένα κόστος στη φάση
   της ανάπτυξης του λογισμικού. Αν κάποιος
   αρχίσει στην Python με μια δημόσια
   μεταβλητή ενός αντικειμένου και στη
   συνέχεια αλλάξει την υλοποίησή της σε
   μια ιδιωτική μεταβλητή που φαίνεται
   μέσα από έναν περιγραφέα ιδιοτήτων, ο
   εσωτερικός κώδικας της κλάσης μπορεί να
   χρειαστεί να διορθωθεί ώστε να
   χρησιμοποιεί την ιδιωτική μεταβλητή και
   όχι τη δημόσια. Η Ruby αφαιρεί αυτήν την
   επιλογή της σχεδίασης, επιβάλλοντας
   όλες οι μεταβλητές αντικειμένων να
   είναι ιδιωτικές, αλλά παρέχει έναν απλό
   τρόπο να ορίζονται μέθοδοι get και set. Αυτό
   συμφωνεί με την ιδέα ότι στη Ruby, κανείς
   δεν έχει άμεση πρόσβαση στα εσωτερικά
   μέλη μιας κλάσης από το εξωτερικό της
   αλλά μπορεί μόνο να στείλει ένα μήνυμα
   στην κλάση και να λάβει μια απάντηση.

   Δείτε τα παραδείγματα για δείγματα
   κώδικα που δείχνουν τη σύνταξη της Ruby.

[Επεξεργασία] Διαφορές στη συμπεριφορά σε
σχέση με άλλες γλώσσες

   Κάποια χαρακτηριστικά που διαφέρουν
   σημαντικά σε σχέση με γλώσσες όπως η C ή η
   Perl:

     * Η σύνταξη της γλώσσας διακρίνει
       μεταξύ κεφαλαίων και μικρών στα
       αναγνωριστικά (identifiers), θεωρώντας ότι
       οι μεταβλητές με κεφαλαία είναι
       σταθερές.
     * Τα σύμβολα $ και @ δεν δείχνουν τον τύπο
       της μεταβλητής όπως στην Perl, αλλά την
       εμβέλειά της.
     * Για να δείξετε έναν αριθμό κινητής
       υποδιαστολής χωρίς δεκαδικό μέρος,
       πρέπει να τελειώνει σε 0 (99.0) ή να
       μετατρέπεται ρητά (99.to_f). Δεν αρκεί να
       προστεθεί η τελεία (99.) γιατί οι
       αριθμοί ακολουθούν τη σύνταξη των
       μεθόδων.
     * Η αποτίμηση τιμών αληθείας δεδομένων
       που δεν είναι αυτού του τύπου είναι
       αυστηρή: το 0, το "" και το [] αποτιμώνται
       σε true. Στη C, η έκφραση 0 ? 1 : 0 αποτιμάται
       σε 0 (δηλ. false). Στη Ruby, όμως, επιστρέφει 1,
       γιατί όλοι οι αριθμοί αποτιμώνται σε
       true; μόνο το nil και το false αποτιμώνται σε
       false. Ένα αποτέλεσμα αυτού του κανόνα
       είναι ότι οι μέθοδοι της Ruby κατά
       σύμβαση — για παράδειγμα, οι
       αναζητήσεις κανονικών εκφράσεων —
       όταν επιτύχουν επιστρέφουν αριθμούς,
       συμβολοσειρές, λίστες ή άλλες τιμές
       που δεν είναι false αλλά επιστρέφουν nil
       όταν αποτύχουν. Αυτή η σύμβαση
       χρησιμοποιείται επίσης και στη Smalltalk,
       όπου μόνο τα ειδικά αντικείμενα true και
       false μπορούν να χρησιμοποιηθούν σε μια
       έκφραση αλήθειας.
     * Οι εκδόσεις πριν την 1.9 χρησιμοποιούν
       απλούς ακέραιους για να
       αναπαραστήσουν τους χαρακτήρες, όπως
       στη C. Αυτό μπορεί να προκαλέσει
       εκπλήξεις όταν τεμαχίζονται οι
       συμβολοσειρές: το "abc"[0] επιστρέφει 97
       (τον κώδικα ASCII του πρώτου χαρακτήρα
       της συμβολοσειράς) - για να πάρουμε "a"
       πρέπει να χρησιμοποιηθεί η "abc"[0,1]
       (υποσυμβολοσειρά μήκους 1) ή η "abc"[0].chr.
     * Η έκφραση statement until expression, σε αντίθεση
       με τις αντίστοιχες εντολές άλλων
       γλωσσών (π.χ. do { statement } while (!(expression)); στη
       C/C++/...), στην πραγματικότητα δεν τρέχει
       ποτέ την εντολή statement αν η έκφραση
       expression είναι ήδη αληθής. Αυτό συμβαίνει
       γιατί η statement until expression είναι στην
       πραγματικότητα μια πιο φιλική μορφή
       (syntactic sugar) της until expression; statement; end, η
       αντίστοιχη της οποίας στη C/C++ είναι η
       while (!(expression)) { statement; }, όπως η statement if
       expression είναι ισοδύναμη με την if (expression) {
       statement; }. Όμως, η σύνταξη begin statement end until
       expression στη Ruby θα εκτελέσει την εντολή
       statement μια φορά ακόμα και αν η έκφραση
       expression είναι ήδη αληθής, μια
       συμπεριφορά που μοιάζει με αυτή του
       "do-while" άλλων γλωσσών.
     * Επειδή οι σταθερές είναι αναφορές σε
       αντικείμενα, η αλλαγή αυτού στο οποίο
       δείχνει μια μεταβλητή δημιουργεί μια
       προειδοποίηση αλλά η τροποποίηση του
       ίδιου του αντικειμένου όχι. Για
       παράδειγμα, ο κώδικας Greeting << " world!" if
       Greeting == "Hello" δεν εμφανίζει κάποιο
       μήνυμα λάθους η προειδοποίησης. Αυτό
       είναι παρόμοιο με τις μεταβλητές final
       της Java ή με τους δείκτες const σε μη-const
       αντικείμενα στη C++, αλλά η Ruby επιτρέπει
       το "πάγωμα" ενός αντικειμένου, σε
       αντίθεση με τη Java.

   Κάποια χαρακτηριστικά που διαφέρουν σε
   σχέση με άλλες γλώσσες:

     * Οι συνηθισμένοι τελεστές για
       εκφράσεις συνθήκης, and και or, δεν
       ακολουθούν τους κανονικούς κανόνες
       προτεραιότητας: ο and δεν έχει
       προτεραιότητα έναντι του or. Η Ruby
       επίσης έχει τελεστές εκφράσεων || και &&
       που δουλεύουν με τον κλασικό τρόπο.

[Επεξεργασία] Αλληλεπίδραση

           Δείτε επίσης Interactive Ruby Shell

   Η επίσημη διανομή της Ruby περιλαμβάνει το
   "irb", έναν αλληλεπιδραστικό διερμηνέα
   γραμμής εντολών που μπορεί να
   χρησιμοποιηθεί για γρήγορες δοκιμές
   κώδικα. Το παρακάτω κομμάτι κώδικα
   αναπαριστά ένα παράδειγμα χρήσης του irb:

 $ irb
 irb(main):001:0> puts "Hello, World"
 Hello, World
 => nil
 irb(main):002:0> 1+2
 => 3

[Επεξεργασία] Παραδείγματα

   Τα παρακάτω παραδείγματα μπορούν να
   εκτελεστούν από ένα κέλυφος της Ruby όπως
   το Interactive Ruby Shell ή να αποθηκευτούν σε ένα
   αρχείο και να εκτελεστούν από τη γραμμή
   εντολών γράφοντας ruby <filename>.

   Το κλασικό παράδειγμα Hello world:

 puts "Hello World!"

   Βασικός κώδικας σε Ruby:

 # Τα πάντα, συμπεριλαμβανομένων των τιμών, είναι αντικείμενα, επομένως αυτό δουλεύει:
 -199.abs                                                # 199
 "ruby is cool".length                                   # 12
 "Your mother is nice.".index("u")                       # 2
 "Nice Day Isn't It?".downcase.split("").uniq.sort.join  # " '?acdeinsty"

   Μετατροπές:

 puts "What's your favorite number?"
 number = gets.chomp
 output_number = number.to_i + 1
 puts output_number.to_s + ' is a bigger and better favorite number.'

  [Επεξεργασία] Συμβολοσειρές

   Υπάρχουν διάφοροι τρόποι να δηλωθούν
   συμβολοσειρές στη Ruby.

   Τα παρακάτω παραδείγματα είναι
   ισοδύναμα και υποστηρίζουν την
   παρεμβολή συμβολοσειρών (interpolation):

 a = "\nThis is a double-quoted string\n"
 a = %Q{\nThis is a double-quoted string\n}
 a = %{\nThis is a double-quoted string\n}
 a = %/\nThis is a double-quoted string\n/
 a = <<-BLOCK

 This is a double-quoted string
 BLOCK

   Οι παρακάτω αναθέσεις είναι ισοδύναμες
   και παράγουν βασικές συμβολοσειρές:

 a = 'This is a single-quoted string'
 a = %q{This is a single-quoted string}

  [Επεξεργασία] Συλλογές

   Δημιουργία και χρήση ενός πίνακα:

 a = [1, 'hi', 3.14, 1, 2, [4, 5]]

 puts a[2]           # 3.14
 puts a.[](2)        # 3.14
 puts a.reverse      # [[4, 5], 2, 1, 3.14, 'hi', 1]
 puts a.flatten.uniq # [1, 'hi', 3.14, 2, 4, 5]

   Δημιουργία και χρήση ενός πίνακα
   συσχετίσεων (πίνακες κατακερματισμού ή
   hashes στη Ruby):

 hash = { :water => 'wet', :fire => 'hot' }
 puts hash[:fire] # Τυπώνει:  hot

 hash.each_pair do |key, value| # Ή:  hash.each do |key, value|
   puts "#{key} is #{value}"
 end

 # Τυπώνει: water is wet
 #          fire is hot

 hash.delete :water # Σβήνει το :water => 'wet'
 hash.delete_if {|key,value| value=='hot'} # Σβήνει το :fire => 'hot'

  [Επεξεργασία] Ενότητες και απαριθμητές

   Σύνταξη με δύο τρόπους για τη δημιουργία
   ενοτήτων κώδικα:

 { puts "Hello, World!" } # Παρατηρήστε τις { αγκύλες }
 #ή
 do puts "Hello, World!" end

   Όταν δημιουργείται μια ενότητα κώδικα,
   πάντα είναι συνδεδεμένη με μια μέθοδο,
   ως προαιρετική παράμετρο της ενότητας.

   Πέρασμα σαν παράμετρο μιας ενότητας για
   να είναι κλείσιμο:

 # Σε μια μεταβλητή αντικειμένου (σημειώνεται με '@') καταγράφεται η ενότητα.
 def remember(&a_block)
   @block = a_block
 end

 # Κλήση της παραπάνω μεθόδου, της δίνεται μια ενότητα που παίρνει ένα όνομα.
 remember {|name| puts "Hello, #{name}!"}

 # Όταν πρέπει (για το αντικείμενο) -- κάλεσε το κλείσιμο!
 @block.call("Jon")
 # => "Hello, Jon!"

   Δημιουργία μιας ανώνυμης συνάρτησης:

 proc {|arg| print arg}
 Proc.new {|arg| print arg}
 lambda {|arg| print arg}

   Επιστροφή ενός κλεισίματος από μια
   μέθοδο:

 def create_set_and_get(initial_value=0) # Εξ'ορισμού τιμή  0
   closure_value = initial_value
   return Proc.new {|x| closure_value = x}, Proc.new { closure_value }
 end

 setter, getter = create_set_and_get  # δηλ. επιστρέφει δυο τιμές
 setter.call(21)
 getter.call # => 21

 #Μπορείτε επίσης να χρησιμοποιήσετε μια μεταβλητή παράμετρο σαν δέσμευση για το κλείσιμο.
 #Το παραπάνω μπορεί να γραφεί σαν...

 def create_set_and_get(closure_value=0)
   proc {|x| closure_value = x } , proc { closure_value }
 end

   Αποδίδοντας τη ροής του ελέγχου
   προγράμματος σε μια ενότητα που δόθηκε
   στο χρόνο κλήσης:

 def use_hello
   yield "hello"
 end

 # Κλήση της παραπάνω μεθόδου, δίνοντάς της μια ενότητα.
 use_hello {|string| puts string} # => 'hello'

   Απαρίθμηση ακολουθιών και πινάκων με τη
   χρήση ενοτήτων:

 array = [1, 'hi', 3.14]
 array.each {|item| puts item }
 # => 1
 # => 'hi'
 # => 3.14

 array.each_index {|index| puts "#{index}: #{array[index]}" }
 # => 0: 1
 # => 1: 'hi'
 # => 2: 3.14

 (3..6).each {|num| puts num }
 # => 3
 # => 4
 # => 5
 # => 6

   Μια μέθοδος όπως η inject() μπορεί να
   δέχεται και μια παράμετρο και μια
   ενότητα. Η inject εκτελείται σε κάθε μέλος
   μιας λίστας, εκτελώντας κάποια
   συνάρτηση σε αυτό, κρατώντας ένα σύνολο.
   Αυτό είναι ανάλογο με τη συνάρτηση foldl
   στις συναρτησιακές γλώσσες
   προγραμματισμού. Για παράδειγμα:

 [1,3,5].inject(10) {|sum, element| sum + element} # => 19

   Στο πρώτο πέρασμα, η ενότητα δέχεται το 10
   (την παράμετρο) σαν sum, και το 1 (το πρώτο
   στοιχείο του πίνακα) σαν στοιχείο και
   επιστρέφει 11. Το 11 τότε γίνεται το sum του
   επόμενου περάσματος, που προστίθεται
   στο 3 για να γίνει 14. Το 14 στη συνέχεια
   προστίθεται στο 5, για να επιστρέψει
   τελικά 19.

   Οι ενότητες δουλεύουν με πολλές
   ενσωματωμένες μεθόδους:

 File.open('file.txt', 'w') do |file| # 'w' σημαίνει "γράψιμο".
   file.puts 'Wrote some text.'
 end                                  # Το αρχείο κλείνει αυτόματα εδώ

 File.readlines('file.txt').each do |line|
   puts line
 end
 # => Wrote some text.

   Χρησιμοποιώντας μια απαρίθμηση και μια
   ενότητα για να πάρουμε το τετράγωνο των
   αριθμών από το 1 ως το 10:

 (1..10).collect {|x| x*x} # => [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

  [Επεξεργασία] Κλάσεις

   Ο παρακάτω κώδικας ορίζει μια κλάση με
   το όνομα Person. Εκτός του 'initialize', του
   κλασικού κατασκευαστή που δημιουργεί
   νέα αντικείμενα, έχει δύο μεθόδους: μια
   που αντικαθιστά τον τελεστή σύγκρισης <=>
   (ώστε το Array#sort να ταξινομεί κατά ηλικία)
   και μια που αντικαθιστά τη μέθοδο to_s
   (ώστε η Kernel#puts να μπορεί να μορφοποιήσει
   την έξοδό της). Εδώ ο κώδικας "attr_reader"
   είναι ένα παράδειγμα
   μεταπρογραμματισμού σε Ruby: η "attr_accessor"
   ορίζει μεθόδους "getter" και "setter" των
   μεθόδων των αντικειμένων, ενώ η "attr_reader"
   μόνο μεθόδους "getter". Επίσης, η τελευταία
   αποτιμημένη εντολή μιας μεθόδου είναι
   και η τιμή που επιστρέφει, επιτρέποντας
   την παράλειψη της ρητής εντολής 'return'.

 class Person
   attr_reader :name, :age
   def initialize(name, age)
     @name, @age = name, age
   end
   def <=>(person) # Τελεστής σύγκρισης για ταξινόμηση
     @age <=> person.age
   end
   def to_s
     "#@name (#@age)"
   end
 end

 group = [
   Person.new("Bob", 33),
   Person.new("Chris", 16),
   Person.new("Ash", 23)
 ]

 puts group.sort.reverse

   Τα παραπάνω τυπώνουν τρία ονόματα σε
   αντίστροφη σειρά ηλικίας:

 Bob (33)
 Ash (23)
 Chris (16)

    [Επεξεργασία] Ανοιχτές κλάσεις

   Στη Ruby οι κλάσεις δεν είναι ποτέ
   κλειστές: μπορείτε πάντα να προσθέσετε
   μεθόδους σε μια υπάρχουσα κλάση. Αυτό
   εφαρμόζεται τόσο στις κλάσεις που
   γράφετε, όσο και στις ενσωματωμένες
   κλάσεις. Το μόνο που έχετε να κάνετε
   είναι να ανοίξετε τον ορισμό μιας
   υπάρχουσας κλάσης, και τα νέα
   περιεχόμενα που θα ορίσετε θα
   προστεθούν εκεί. Ένα απλό παράδειγμα
   πρόσθεσης μια νέας μεθόδου στην κλάση Time
   της βασικής βιβλιοθήκης:

 # ξανα-ανοίγει την κλάση Time της Ruby
 class Time
   def yesterday
     self - 86400
   end
 end

 today = Time.now # => Thu Aug 14 16:51:50 +1200 2008
 yesterday = today.yesterday # => Wed Aug 13 16:51:50 +1200 2008

   Η προσθήκη μεθόδων σε κλάσεις που έχουν
   ήδη οριστεί συχνά ονομάζεται
   "μπάλωμα-μαϊμού" (monkey-patching). Η πρακτική
   αυτή, μπορεί να οδηγήσει σε πιθανές
   συγκρούσεις όσον αφορά τη συμπεριφορά
   του κώδικα και στη συνέχεια σε
   απρόβλεπτα αποτελέσματα. Αν
   ακολουθείται χωρίς προσοχή μπορεί να
   οδηγήσει σε πρόβλημα διαχείρισης του
   μεγέθους του κώδικα.

  [Επεξεργασία] Εξαιρέσεις

   Μια εξαίρεση εμφαίζεται με την κλήση της
   raise:

 raise

   Σε μια εξαίρεση μπορεί να προστεθεί ένα
   προαιρετικό μήνυμα:

 raise "This is a message"

   Μπορεί επίσης να δοθεί ο τύπος της
   εξαίρεσης:

 raise ArgumentError, "Illegal arguments!"

   Εναλλακτικά μπορείτε να περάσετε ένα
   στιγμιότυπο μιας εξαίρεσης στη μέθοδο
   raise:

 raise ArgumentError.new("Illegal arguments!")

   Το παρακάτω σχήμα κώδικα είναι χρήσιμο
   όταν θέλετε να εμφανιστεί μια εξαίρεση
   κάποιας ιδιαίτερης κλάσης που έχει
   κατασκευαστή με περισσότερα του ενός
   ορίσματα:

 class ParseError < Exception
   def initialize input, line, pos
     super "Could not parse '#{input}' at line #{line}, position #{pos}"
   end
 end

 raise ParseError.new("Foo", 3, 9)

   Οι εξαιρέσεις χειρίζονται από την
   πρόταση rescue. Μια τέτοια πρόταση μπορεί
   να πιάσει τις εξαιρέσεις που
   κληρονομούν από την StandardError. Επίσης οι else
   και ensure υποστηρίζουν τη χρήση με
   εξαιρέσεις.

 begin
 # Κάνε κάτι
 rescue
 # Χειρισμός της εξαίρεσης
 else
 # Αλλιώς κάνε αυτό αν δεν εμφανίστηκε εξαίρεση
 ensure
 # Κάνε αυτό σε κάθε περίπτωση (είτε εμφανίστηκε εξαίρεση ή όχι)
 end

   Ένα κοινό λάθος είναι να προσπαθείτε να
   πιάσετε όλες τις εξαιρέσεις με μια μόνο
   πρόταση rescue. Αυτό γίνεται σωστά ως εξής:

 begin
 # Κάνε κάτι
 rescue Exception # όχι απλά rescue -- αυτό πιάνει μόνο την StandardError, υποκλάση της Exception
 # Χειρισμός της εξαίρεσης
 end

   Ο χειρισμός συγκεκριμένων εξαιρέσεων
   γίνεται ως εξής:

 begin
 # ...
 rescue RuntimeError
 # χειρισμός
 end

   Επίσης το αντικείμενο της εξαίρεσης
   μπορεί να γίνει διαθέσιμο στο σώμα
   κώδικα του χειριστή της εξαίρεσης:

 begin
 # ...
 rescue RuntimeError => e
 # χειριστής που μπορεί να χρησιμοποιεί το e, όπως η "print e.to_s"
 end

   Εναλλακτικά η πιο πρόσφατη εξαίρεση
   αποθηκεύεται στη "μαγική" καθολική
   μεταβλητή $!.

   Μπορείτε επίσης να πιάσετε πολλές
   εξαιρέσεις:

 begin
 # ...
 rescue RuntimeError, Timeout::Error => e
 # χειριστής που μπορεί να χρησιμοποιεί το e
 end

  [Επεξεργασία] Μεταπρογραμματισμός

   Ο κώδικας σε Ruby μπορεί προγραμματιστικά
   να αλλάζει, στο χρόνο εκτέλεσης, όψεις
   της ίδιας του της δομής που θα ήταν
   σταθερές σε πιο αυστηρές γλώσσες, όπως
   οι ορισμοί των κλάσεων και των μεθόδων.
   Αυτός ο τρόπος μεταπρογραμματισμού
   μπορεί να χρησιμοποιηθεί για να γραφεί
   συντομότερος κώδικας ή να επεκταθεί
   πρακτικά η γλώσσα.

   Για παράδειγμα, ο ακόλουθος κώδικας σε
   Ruby δημιουργεί νέες μεθόδους για την
   ενσωματωμένη κλάση String για τις
   συμβολοσειρές, με βάση μια λίστα από
   χρώματα. Οι μέθοδοι περικλείουν τα
   περιεχόμενα μιας συμβολοσειράς με
   κώδικα HTML με το κατάλληλο χρώμα.

 COLORS = { :black   => "000",
            :red     => "f00",
            :green   => "0f0",
            :yellow  => "ff0",
            :blue    => "00f",
            :magenta => "f0f",
            :cyan    => "0ff",
            :white   => "fff" }

 class String
   COLORS.each do |color,code|
     define_method "in_#{color}" do
       "<span style=\"color: ##{code}\">#{self}</span>"
     end
   end
 end

   Οι μέθοδοι που προκύπτουν τότε μπορούν
   να χρησιμοποιηθούν ως εξής:

 "Hello, World!".in_blue

    => "<span style=\"color: #00f\">Hello, World!</span>"

   Για να υλοποιηθεί κάτι αντίστοιχο σε
   άλλες γλώσσες, ο προγραμματιστής θα
   έπρεπε να γράψει κάθε μέθοδο (in_black, in_red,
   in_green, κλπ.) με το χέρι.

   Κάποιες άλλες πιθανές χρήσεις του
   μεταπρογραμματισμού σε Ruby
   περιλαμβάνουν:

     * υποκλοπή και τροποποίηση κλήσεων
       συναρτήσεων
     * υλοποίηση νέων μοντέλων
       κληρονομικότητας
     * δυναμική παραγωγή κλάσεων από
       παραμέτρους
     * αυτόματη σειριακοποίηση (serialization)
       αντικειμένων
     * διαδραστική βοήθεια και
       αποσφαλμάτωση

[Επεξεργασία] Υλοποιήσεις

   Η έκδοση 1.9 της Ruby, αποτελείται από μια
   μοναδική υλοποίηση γραμμένη σε C που
   χρησιμοποιεί μια εικονική μηχανή ειδική
   για Ruby.

   Η έκδοση 1.8 της Ruby έχει δυο βασικές
   υλοποιήσεις: τον επίσημο διερμηνέα της
   Ruby, ο οποίος συχνά αποκαλείται και "Ο
   διερμηνέας του Matz για τη Ruby" ή MRI, και
   είναι αυτός που χρησιμοποιείται πιο
   συχνά, και τη JRuby, μια υλοποίηση
   βασισμένη σε Java που εκτελείται στην
   εικονική μηχανή της Java.

   Υπάρχουν και άλλες λιγότερο γνωστές ή
   νεότερες υλοποιήσεις όπως η Cardinal
   (υλοποιημένη στην εικονική μηχανή Parrot), η
   IronRuby,^[21] η MacRuby, η MagLev, η Rubinius, η Ruby.NET, η XRuby
   και η HotRuby (εκτελεί κώδικα Ruby σε
   φυλλομετρητές ιστού και στην πλατφόρμα
   Flash).

   Το πόσο ώριμη είναι μια υλοποίηση της Ruby
   συνήθως μετράται από το αν είναι ικανή
   να εκτελεί το πλαίσιο Ruby on Rails (Rails), γιατί
   είναι πολύπλοκο στην υλοποίηση και
   χρησιμοποιεί πολλά χαρακτηριστικά που
   είναι μόνο διαθέσιμα στη Ruby. Το σημείο
   στο οποίο μια υλοποίηση μπορεί να το
   πετύχει αυτό, ονομάζεται η μοναδικότητα
   των Rails (The Rails singularity). Μέχρι το Μάιο του
   2010, μόνο η βασική υλοποίηση (MRI) και η JRuby
   μπορούν να εκτελέσουν το Rails χωρίς
   τροποποιήσεις σε ένα περιβάλλον
   παραγωγής. Η Rubinius κυκλοφόρησε την έκδοση
   1.0 που μπορεί να εκετελεί το Rails,^[22] αλλά
   δεν είναι σίγουρο ότι μπορεί να
   χρησιμοποιηθεί σε περιβάλλοντα
   παραγωγής ακόμα.^[23] Η IronRuby^[24]^[25] μπορεί
   να τρέξει κάποιες δοκιμαστικές
   περιπτώσεις του Rails, αλλά ακόμα δεν είναι
   έτοιμη για περιβάλλοντα παραγωγής.

   Η Ruby είναι διαθέσιμη σε πολλά
   λειτουργικά συστήματα όπως το Linux, το Mac OS
   X, τα Microsoft Windows, τα Windows CE και οι πιο πολλές
   εκδόσεις του Unix.

   Η Ruby 1.9 πρόσφατα μεταφέρθηκε στο Symbian OS
   9.x.^[26]

[Επεξεργασία] Αποθήκες κώδικα και
βιβλιοθήκες

   Το Ruby Application Archive (RAA) και το RubyForge,
   λειτουργούν σαν αποθήκες κώδικα (repositories)
   για πολλές εφαρμογές και βιβλιοθήκες
   της Ruby, περιλαμβάνοντας πάνω από 7000
   αντικείμενα. Αν και ο αριθμός των
   εφαρμογών που είναι διαθέσιμος δεν
   είναι ίδιος με αυτόν των κοινοτήτων της
   Perl ή της Python, υπάρχουν πολλά εργαλεία που
   ενθαρρύνουν την περαιτέρω ανάπτυξη
   κώδικα στη γλώσσα.

   Ο RubyGems έχει γίνει ο βασικός διαχειριστής
   πακέτων για βιβλιοθήκες σε Ruby. Ο σκοπός
   του μοιάζει με το CPAN της Perl αλλά η χρήση
   του μοιάζει πιο πολύ με το apt-get.

   Πρόσφατα πολλές παλιές και νέες
   βιβλιοθήκες στεγάζονται στο GitHub, το
   οποίο εστιάζει στο Git και είχε βασική
   υποστήριξη για πακετάρισμα RubyGems.^[27]

[Επεξεργασία] Δείτε επίσης

     * Duck typing
     * JRuby
     * HotRuby
     * MacRuby
     * IronRuby
     * Rubinius
     * Ruby on Rails
     * YARV
     * Interactive Ruby Shell

[Επεξεργασία] Αναφορές

    1. ↑ http://www.ruby-lang.org/en/about/ Ruby-Lang About Ruby
       (Αγγλικά)
    2. ↑ ^2,0 ^2,1
       http://www.linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html An
       Interview with the Creator of Ruby (Αγγλικά)
    3. ↑ ^3,0 ^3,1 ^3,2
       http://blog.nicksieger.com/articles/2006/10/20/rubyconf-history-of-ruby
       Ιστρία της Ruby (Αγγλικά)
    4. ↑ http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/88819
       "[FYI: historic] The decisive moment of the language name Ruby. (Re:
       [ANN] ruby 1.8.1)" - Email από τον Hiroshi Sugihara στη
       ruby-talk (Αγγλικά)
    5. ↑ http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/394
       "Re: the name of Ruby?" - Email από τον Yukihiro Matsumoto
       στη ruby-talk
    6. ↑ http://eigenclass.org/hiki/ruby+0.95 More archeolinguistics:
       unearthing proto-Ruby (Αγγλικά)
    7. ↑ http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/382
       "Re: history of ruby" - Email from Yukihiro Matsumoto to ruby-talk
       (Αγγλικά)
    8. ↑ http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-list/124
       "TUTORIAL - ruby's features" - Email από το Yukihiro Matsumoto
       στη ruby-list
    9. ↑ [1]
   10. ↑ The Ruby Programming Language by Yukihiro Matsumoto on 2000-06-12
       (informit.com)
   11. ↑ ^11,0 ^11,1 ^11,2 The Philosophy of Ruby, A Conversation with
       Yukihiro Matsumoto, Part I by Bill Venners on 2003-09-29 (Artima
       Developer) (Αγγλικά)
   12. ↑ Ruby Weekly News 23rd - 29th May 2005
   13. ↑ An Interview with the Creator of Ruby (Αγγλικά)
   14. ↑ Dynamic Productivity with Ruby (Αγγλικά)
   15. ↑ martinfowler.com (Αγγλικά)
   16. ↑ Blocks and Closures in Ruby {{en}
   17. ↑ Unicode support in Ruby is too buggy compared to similar
       programming languages (Αγγλικά)
   18. ↑ πράσινα νήματα
   19. ↑ Ruby FAQ (Αγγλικά)
   20. ↑ In Ruby's syntax, statement is just a special case of an
       expression which cannot appear as an argument (e.g. multiple
       assignment).
       http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/1120
       statement [...] can not be part of expression unless grouped within
       parentheses.
       http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/2460
   21. ↑ Lam, John (2008-07-24). IronRuby at OSCON (ανακτήθηκε
       2008-08-04 )
   22. ↑ Peter Cooper (2010-05-18). The Why, What, and How of Rubinius
       1.0's Release
   23. ↑ Charles Nutter (2008-04-27). Promise and Peril for Alternative
       Ruby Impls (ανακτήθηκε 2008-06-01 )
   24. ↑ John Lam (2008-05-25). IronRuby / Rails Question
       (ανακτήθηκε 2008-05-25 )
   25. ↑ John Lam (2008-05-30). IronRuby and Rails (ανακτήθηκε
       2008-06-01 )
   26. ↑ Ruby 1.9 for Symbian OS (ανακτήθηκε 2008-12-03 )
   27. ↑ Gem Building is Defunct, GitHub Blog

[Επεξεργασία] Βιβλιογραφία

     * McAnally, Jeremy; Arkin, Assaf (March 28, 2009), Ruby in Practice
       (Πρώτη έκδοση), Manning Publications, σελ. 360, ISBN
       1933988479, http://www.manning.com/mcanally/
     * Thomas, Dave; Fowler, Chad; Hunt, Andy (April 28, 2009), Programming
       Ruby 1.9: The Pragmatic Programmers' Guide (Τρίτη έκδοση),
       Pragmatic Bookshelf, σελ. 1000, ISBN 1934356085,
       http://pragprog.com/titles/ruby3/programming-ruby-1-9
     * Flanagan, David; Matsumoto, Yukihiro (January 25, 2008), The Ruby
       Programming Language (Πρώτη έκδοση), O'Reilly Media,
       σελ. 446, ISBN 0596516177,
       http://oreilly.com/catalog/9780596516178/
     * Baird, Kevin (June 8, 2007), Ruby by Example: Concepts and Code
       (Πρώτη έκδοση), No Starch Press, σελ. 326, ISBN
       1593271484, http://nostarch.com/ruby.htm
     * Fitzgerald, Michael (May 14, 2007), Learning Ruby (Πρώτη
       έκδοση), O'Reilly Media, σελ. 255, ISBN 0596529864,
       http://oreilly.com/catalog/9780596529864
     * Cooper, Peter (March 26, 2007), Beginning Ruby: From Novice to
       Professional (Πρώτη έκδοση), Apress, σελ. 664, ISBN
       1590597664, http://apress.com/book/view/9781590597668
     * Fulton, Hal (November 4, 2006), The Ruby Way (Πρώτη
       έκδοση), Addison-Wesley Professional, σελ. 888, ISBN
       0596523696,
       http://www.informit.com/store/product.aspx?isbn=0672328844
     * Carlson, Lucas; Richardson, Leonard (July 19, 2006), Ruby Cookbook
       (Πρώτη έκδοση), O'Reilly Media, σελ. 906, ISBN
       0596523696, http://oreilly.com/catalog/9780596523695/

[Επεξεργασία] Εξωτερικοί σύνδεσμοι

     * Αρθρα για αρχάριους στη Ruby
     * Rubystes: Σελίδα για Έλληνες
       προγραμματιστές της Ruby, ομάδα Google
     * Η επίσημη σελίδα της γλώσσας Ruby
       (Αγγλικά)
     * The Great Ruby Shootout (December 2008): Συγκρίσεις
       μεταξύ υλοποιήσεων της Ruby. (Αγγλικά)
     * Collingbourne, Huw (June 17 2006), The Little Book Of Ruby,
       ελεύθερο eBook σε μορφή PDF 1.1MB (Αγγλικά)
     * Collingbourne, Huw (April 18 2009), The Book Of Ruby, ελεύθερο
       eBook σε μορφή PDF 2.9MB (Αγγλικά)
     * Ruby.on-page.net — απλό εγχειρίδιο της Ruby με
       πολλά παραδείγματα (Αγγλικά)
     * Ruby User Guide Από το Matz, δημιουργό της Ruby.
       Μετάφραση στα Αγγλικά. (Αγγλικά)
     * Η Ruby από την πλευρά άλλων γλωσσών
       (Αγγλικά)
     * RubyFlow: Community Filtered Ruby News (Αγγλικά)
     * The Ruby Reflector Νέα της Ruby (Αγγλικά)

   π • σ • ε
                Γλώσσα προγραμματισμού Ruby
   Ολοκληρωμένα          NetBeans · RubyForge · RadRails ·
   περιβάλλοντα          RubyMine · ActiveState_Komodo
   ανάπτυξης
                                     Ruby MRI · YARV · JRuby · IronRuby ·
   Υλοποιήσεις            Rubinius · XRuby · MacRuby ·
                                     RubyJS · HotRuby
   Εφαρμογές                RubyGems · Rake · Interactive Ruby
                                     Shell · Capistrano
                                     Adhearsion · Camping · eRuby
   Βιβλιοθήκες /          (RHTML) · Hobo · Merb · Nitro ·
   Πλαίσια ανάπτυξης RubyCocoa · Ruby on Rails · Ramaze ·
                                     Sinatra · Padrino · QtRuby
   Λογισμικό                Mongrel · Phusion Passenger
   εξυπηρετητή            (mod_rails/mod_rack) · WEBrick ·
                                     mod_ruby
                                     Application Archives · Document
   Άλλα                          format · Book Guides · Ruby Central ·
                                     Hackety Hack · RubyKaigi
   Κατηγορία

                      Στο άρθρο αυτό έχει
                      ενσωματωθεί κείμενο από το
                      άρθρο Ruby (programming language) της
   Wikipedia-logo.png Αγγλόγλωσσης Βικιπαίδειας, η
                      οποία διανέμεται υπό την GNU FDL
                      και την CC-BY-SA 3.0.
                      (ιστορικό/συντάκτες).

   Ανακτήθηκε από "http://el.wikipedia.org/wiki/Ruby"
   Κατηγορίες: Γλώσσες με δυναμικούς
   τύπους | Αντικειμενοστρεφείς γλώσσες
   προγραμματισμού | Διαδικαστικές γλώσσες
   προγραμματισμού | Γλώσσες
   προγραμματισμού σεναρίων | Ελεύθερο
   λογισμικό | Ruby

      Προσωπικά εργαλεία

     * Νέα χαρακτηριστικά
     * Δημιουργία Λογαριασμού/Είσοδος

      Περιοχές ονομάτων

     * Άρθρο
     * Συζήτηση

      Παραλλαγές

      Εμφανίσεις

     * Ανάγνωση
     * Επεξεργασία
     * Προβολή ιστορικού

      Ενέργειες

      Αναζήτηση

   _____________________ Αναζήτηση

      Πλοήγηση

     * Κύρια πύλη
     * Κατάλογος άρθρων
     * Αξιόλογα άρθρα
     * Τρέχοντα γεγονότα
     * Τυχαία σελίδα

      Συμμετοχή

     * Πύλη Κοινότητας
     * Αγορά
     * Πρόσφατες αλλαγές
     * Βοήθεια
     * Επικοινωνία
     * Δωρεές

      Εκτύπωση/εξαγωγή

     * Δημιουργία βιβλίου
     * Κατέβασμα ως PDF
     * Έκδοση εκτύπωσης

      Εργαλειοθήκη

     * Συνδέσεις προς εδώ
     * Σχετικές αλλαγές
     * Ειδικές σελίδες
     * Σταθερός σύνδεσμος
     * Παραπομπή

      Άλλες γλώσσες

     * العربية
     * Žemaitėška
     * Български
     * বাংলা
     * Català
     * Soranî / کوردی
     * Česky
     * Dansk
     * Deutsch
     * English
     * Esperanto
     * Español
     * Eesti
     * Euskara
     * فارسی
     * Suomi
     * Français
     * Galego
     * עברית
     * Hrvatski
     * Magyar
     * Interlingua
     * Bahasa Indonesia
     * Italiano
     * 日本語
     * ქართული
     * 한국어
     * Lietuvių
     * മലയാളം
     * Bahasa Melayu
     * မြန်မာဘာသာ
     * Nederlands
     * ‪Norsk (nynorsk)‬
     * ‪Norsk (bokmål)‬
     * Polski
     * Português
     * Română
     * Русский
     * Slovenčina
     * Српски / Srpski
     * Svenska
     * தமிழ்
     * Тоҷикӣ
     * ไทย
     * Türkçe
     * Українська
     * Tiếng Việt
     * 中文
     * 粵語

     * Τελευταία τροποποίηση 23:10, 5
       Σεπτεμβρίου 2010.
     * Όλα τα κείμενα είναι διαθέσιμα υπό την
       Creative Commons Attribution/Share-Alike License· μπορεί να
       ισχύουν και πρόσθετοι όροι. Δείτε τους
       Όρους Χρήσης για λεπτομέρειες.

     * Πολιτική προσωπικών δεδομένων
     * Για τη Βικιπαίδεια
     * Αποποίηση ευθυνών

     * Powered by MediaWiki
     * Wikimedia Foundation
